# CS 225 Data Structures

# Project Proposal (vanshg3-vkowdle2-waltert3-ssg6)

## Leading Question
Our final deliverable will be a tool that can display the debt a nation owes. From a dataset containing the amount of debt a government owes to other organizations, we are hoping to produce a general search that allows anyone to determine the amount of debt owed or owned. The reason as to why we are taking on this project is to graphically visualize how debt is managed from group to group and be able to make a tool that organizes this information.


## Data 
Our dataset will primarily consist of the latest data from this organization which pieces together a curated list of every nation’s debt and the various creditors that they owe money to. There are several steps required for us to make this data useable and accurate. Aftering aggregating the data from our source, we will compose a CSV file that holds the necessary weights to compose a weighted graph. This will allow any individual that wants to run the program access to the data and information. Moreover, the program can then process this data to generate an adjacency matrix. From there various operations can be performed.

## Graph Algorithms
To store the data in a weighted graph, we will implement an adjacency matrix that holds these debt values (country mapped to all the countries it owes money and how much). This will allow us to keep track of the money that Country A to Country B and Country C. Moreover, we can also keep track of self-debt through the adjacency matrix. Although an adjacency matrix takes up n2 memory, there are a limited number of countries, so we wouldn’t need to worry too much about insanely large data inputs when performing our algorithms or traversals. We will be implementing DFS as our traversal. The inputs to the DFS will be the starting node and the ending node that we want to traverse to. Each node is a country and its total debt that they have with pointers to all of its children, or countries that it owes money to. The output of the traversal at every iteration is the current node which is a country, the total debt owed and pointers to all its children. The first algorithm we will implement is Dijkstra’s Algorithm which will help us find the shortest path between two countries in the debt graph. This will be useful to figure out, given two countries, which countries the first country has to pay back to fulfill their debt to the second country. For example, if country A owes money to country B, which owes money to country C. This algorithm, given inputs A and C, would return a list of the shortest path from A to C. The inputs of the algorithm are two country notes and the output is a list of country nodes in the shortest path between the two countries. The time complexity is O(E + VlogV) if E is the number of edges and V is the number of countries. Our other algorithm would be Tarjan's strongly connected components algorithm. This algorithm is able to detect strongly connected components in our graph which indicates whether a cycle is present within our graph. This will be able to track if A owes B which owes C which owes A. We could use a DFS, as it produces a tree, and we can check if there is a cycle by seeing if there is a back edge in the graph, which is a joint node to itself or an ancestor in the tree from DFS. This would have a O(|V| + |E|) runtime. We need to run a DFS from every unvisited node, so our input could be any point in the graph. We would output a bool true/false if there is a cycle or not.

## Timeline
**11/08:** Proposal Deadline\
**11/18:** Having a processing pipeline that is able to load the data in an efficient manner, read through every row, clean any bad parts of the data and be ready to add elements to the graph.\
**11/22:** Write and implement any necessary test cases to test edge behaviour and general behavior. Having simpler methods of graph data structure complete. Such methods would be constructor, add, remove, update, and find. \
**11/30:** Write and implement any necessary test cases to test edge behaviour and general behavior. Have a DFS iterator that can easily traverse both arrays depending on how the user wants it implemented. Develop topological sort and Djstrika's algorithms to be able to organize the graphs information. Have an MVP ready by mid point check-ins to keep pace with the project’s needs.\
**12/07:** Write and implement any necessary test cases to test edge behaviour and general behavior. Implement the search algorithm described above and be able to find any ways to improve efficiency if possible. Begin to get the project wrapped up by the final deadline.\
**12/13:** Build out all necessary documentation related to the project that will allow someone to run and test the application. Check for code quality (add comments, remove unnecessary functions, follow good naming conventions. Add additional test cases to test suite to test project in its entirety.


Varun Kowdle, vkowdle2\
Vansh Gupta, vanshg3
